'''
Привет! 
Меня зовут Саша. Я ревьюер твоего практического задания.
Здесь мы рассмотрим основные моменты твоей работы,
на которые стоит обратить особое внимание.

Все мои заметки по твоему коду можешь найти в комментариях.
Выглядит это так (чтобы не спутать с твоими):
# [Review] Комментарий от Саши

По вопросам смело обращайся в Telegram - @colours7.
Отвечаю по мере доступности, но точно в пределах суток.

Общие мои рекомендации по твоей работе:
1) Форматеры - лучшие друзья программистов. Увы, не всегда мы помним про отступы.
Поэтому программисты придумали форматтеры - удобный инструмент автоматического
форматирования кода. Вот один из самых популярных - https://github.com/psf/black.
Рекомендую установить и прогонять свой код через него.
Тогда и мне, и тебе будет приятнее смотреть на твоё творчество :)

2) Линтеры - тоже друзья программистов, но более строгие.
Это инструмент проверки и анализа кода на логику и соответствие PEP-8 стандарту.
В случае каких-то ошибок он укажет её код и информативное сообщение. Например:
[Pylint: E0401] Import-error on 777 line: Unable to import pytest
Один из популярных линтеров - https://pylint.pycqa.org/en/latest/index.html.
Рекомендую установить и перед отправкой решений проверять свой код таким образом.
P.S.: в твоём коде я указывал коды ошибок линтера там, где он бы поругался.
Можешь отдельно по каждому коду поискать про ошибку в поисковике.

3) Типизация - то, что отличает Питон от многих языков. Рассмотрим пример:
----------------
Java, C++: int a = 3;
Python: a = 3
----------------
Казалось бы - очень удобно, что не нужно заморачиваться с типами при работе в Питоне.
Однако во многих случаях это может сыграть злую шутку. Например:
----------------
def sum(a, b):
    return a + b
----------------
sum(3, 5) -> 8
sum(3, 'hello') -> TypeError: unsupported operand type(s) for +: 'int' and 'str'
----------------
Чтобы немного облегчить жизнь себе и другим разработчикам, использующим твой код,
можно указывать типы (даже есть библиотека typing для этого). Например:
----------------
def sum(a: int, b: int) -> int:
    return a + b
----------------
Такие подсказки (тайп хинты) ни на что не влияют. Интерпретатор не будет ругаться,
исполняя код с несоответствующими указанными типами.
Однако линтер отследит несоответствие и поругается, что поможет в дебаге
и рефакторинге своего кода. Поэтому рекомендую в будущем использовать
тайп хинты для написания более красивого и понятного кода.

4) В будущем хотелось бы видеть больше доки и комментариев в коде.
Это будет даже проще для тебя - лишний повод пройтись по коду
и отследить все неточности своего решения.

5) Разработка бэкенда всегда предполагает тестирование кода.
Не в каждой команде есть позиция тестировщика, поэтому порой бэкендеры
сами тестируют свой код. Советую даже на такие простые домашки иметь
хотя бы один файлик с простенькими тестами (можно даже без использования pytest,
а просто: alert something == other). Хотя твоя работа и прошла автотесты,
раз дошла до проверки ревьюером, всё равно полезной практикой считается
покрытие написанного функционала тестами на выявление багов.

6) Последняя маленькая ремарка. Любой код стоит делить на логические блоки.
Тяжело читать даже самую простую функцию, в которой нет пустых строк-разделителей.
Как это сделать - мы ещё научимся. Пока рекомендую просто задуматься об этом,
пытаясь дробить код на логические части.
'''


import datetime as dt


class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        # [Review] Неправильный перенос. Лучше отформатировать код следующим образом:
        # something = (
        #   other
        #   if condition
        #   else nothing
        # )
        self.date = (
            dt.datetime.now().date() if
            not
            date else dt.datetime.strptime(date, '%d.%m.%Y').date())
        self.comment = comment


class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    def add_record(self, record):
        self.records.append(record)

    def get_today_stats(self):
        today_stats = 0
        # [Review]
        # 1) В Питоне обычно с заглавной буквы идут имена классов или типов.
        # В данном случае нарушается PEP-8 стандарт [Pylint: C0103]
        # 2) Рекомендую почитать про Namespaces и Scopes в Питоне.
        # Здесь имя счётчика Record можно интерпретировать как название класса Record.
        # Хотя программа и сработает корректно,
        # лучше по-разному называть переменные разных скоупов.
        # Иначе код будет труднее читать и дебажить [Pylint: W0621]
        # 3) Каждый раз обращаться к функции datetime.datetime.now() плохая практика,
        # поскольку при огромном количестве записей
        # мы значительно увеличиваем время выполнения программы.
        # Поэтому рекомендую вынести перед циклом переменную
        # today_date=... и использовать её в цикле
        # Кстати, в методе get_week_stats ты так и сделал
        for Record in self.records:
            if Record.date == dt.datetime.now().date():
                # [Review] Ты где-то уже используешь += оператор,
                # предлагаю тут сделать то же самое:
                # today_stats += ...
                today_stats = today_stats + Record.amount
        return today_stats

    def get_week_stats(self):
        week_stats = 0
        today = dt.datetime.now().date()
        for record in self.records:
            # [Review] Оптимальнее и удобнее было бы вынести подвыражение в отдельную переменную:
            # diff = (today - record.date).days
            # Это вызовет меньше путанницы в логике и сделает код более читаемым
            # К тому же условие (today - record.date) неактуально при валидности передаваемых дат
            # (запись не может быть сделана в будущем).
            # Также стоит заметить здесь неправильный перенос выражения.
            if (
                (today - record.date).days < 7 and
                (today - record.date).days >= 0
            ):
                week_stats += record.amount
        return week_stats


class CaloriesCalculator(Calculator):
    # [Review] Комментарии к функции - это прекрасно, но лучше делать это докстрингой:
    # '''
    # Получает остаток калорий на сегодня.
    # '''
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        # [Review] Советую называть переменные осмысленно,
        # чтобы ты и другие разработчики лучше понимали код в будущем.
        # Например: remained_calories = ...
        x = self.limit - self.get_today_stats()
        # [Review]
        # 1) Лайк за перенос, но 'Сегодня можно съесть что-нибудь' можно не делать f-строкой
        # 2) В этом выражении else избыточно - лучше сделать так:
        # if some_condition:
        #   return something
        # return other
        # Логически ничего не поменяется, но код будет читабельнее
        # за счёт return выражения в конце функции.
        # Это своего рода гарантия, что мы обязательно что-то возвращаем [Pylint: R1705]
        # 3) 'Хватит есть!' излишне оборачивать в скобки
        if x > 0:
            # [Review] Для переноса строки лучше использовать скобки по следующим причинам:
            # 1) Скобок две, а слэшей надо по одному на каждый перенос
            # 2) Можно забыть прописать один из слэшей
            # или случайно поставить пробел после него, что сломает код.
            return f'Сегодня можно съесть что-нибудь' \
                   f' ещё, но с общей калорийностью не более {x} кКал'
        else:
            return('Хватит есть!')


class CashCalculator(Calculator):
    # [Review] В Python2 было бы актуально кастить делитель или делимое во float,
    # чтобы произвести именно нецелочисленное деление
    # В Python3 это неактуально, поскольку деление предоставляет оператор __truediv__,
    # которому можно передавать целые числа и получить дробный результат.
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.

    # [Review]
    # 1) Здесь как раз выстрелило то, о чём я писал выше.
    # Лучше иметь return на уровне функции, чтобы логика написанного была яснее [Pylint: R1710]
    # То есть последний elif убрать и прописать return отдельно.
    # 2) Излишне передавать в этот метод константы напрямую, когда они объявлены на уровне класса.
    # Тем более это нарушение неймингов аргументов функции
    # (они должны быть написаны в нижнем регистре) [Pylint: C0103]
    # К тому же по заданию данная функция принимает только один аргумент - currency.
    def get_today_cash_remained(self, currency,
                                USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        # [Review] По ясности и кодстайлу было бы логичнее инициализировать так: currency_type = ''
        currency_type = currency
        cash_remained = self.limit - self.get_today_stats()
        # [Review] Для подобных случаев полезно использовать Enum.
        # Это собирательный класс констант, которые обычно относятся к одной логической группе.
        # Например:
        # class Currency(enum.Enum):
        #   USD = 'usd'
        #   Euro = 'eur'
        #   rub = 'руб'
        # Тогда сравнение и присваивание будет удобнее:
        # if currency == Currency.USD.value:
        #   ...
        #   currency_type = Currency.USD.name
        # Но даже такой подход я бы не рекомендовал использовать здесь.
        # Во-первых, неконсистентно использовать разный регистр констант в Enum классе
        # Во-вторых, можно упростить количество if выражений, используя словарь:
        # currency_type_map = {'usd': 'USD', 'eur': 'Euro', 'rub': 'руб'}
        # currency_rate_map = {'USD': USD_RATE, 'eur': EURO_RATE, 'rub': 1}
        # При гарантии входных данных, соответствующих ключам словаря,
        # можно упростить функцию следующим образом:
        # currency_type = currency_type_map[currency]
        # cash_remained /= currency_rate_map[currency_type]
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            # [Review] Выражение бессмысленно,
            # поскольку проигнорируется интерпретатором [Pylint: W0104]
            cash_remained == 1.00
            currency_type = 'руб'
        if cash_remained > 0:
            return (
                f'На сегодня осталось {round(cash_remained, 2)} '
                f'{currency_type}'
            )
        elif cash_remained == 0:
            return 'Денег нет, держись'
        # [Review] Это тот самый elif, который здесь не играет роли.
        # Так или иначе cash_remained < 0, если предыдущие условия пропустились.
        # Поэтому предлагаю убрать этот elif
        # и оставить return выражение само по себе [Pylint: R1705]
        elif cash_remained < 0:
            # [Review] Лучше придерживаться единого кодстайла.
            # Поэтому если ты начал использовать f-стринги,
            # то лучше так делать во всём коде модуля.
            return 'Денег нет, держись:' \
                   ' твой долг - {0:.2f} {1}'.format(-cash_remained,
                                                     currency_type)

    # Априори этот метод наследуется у родительского класса.
    # Поэтому если не модифицируем наследованный метод,
    # то следующие строки можно просто убрать [Pylint: W0235]
    def get_week_stats(self):
        super().get_week_stats()
